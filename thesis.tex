%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% I, the copyright holder of this work, release this of into the
%% public domain. This applies worldwide. In some countries this may
%% not be legally possible; if so: I grant anyone the right to use
%% this work for any purpose, without any conditions, unless such
%% conditions are required by law.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[
    %twoside,   % Printed version
    %printed,   % Printed version
    digital,    % PC version
    oneside,    % PC version
    color,
    11pt,
    nocover,
    notable,
    nolof,
    nolot,
    final
  %% More options are listed in the user guide at
  %% <http://mirrors.ctan.org/macros/latex/contrib/fithesis/guide/mu/fi.pdf>.
]{fithesis3}
%% The following section sets up the locales used in the thesis.
\usepackage[resetfonts]{cmap} %% We need to load the a T2A font encoding
%\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}  % T2a commented %% to use the Cyrillic fonts with Russian texts.
\usepackage[
  main=english, %% By using `czech` or `slovak` as the main locale
                %% instead of `english`, you can typeset the thesis
                %% in either Czech or Slovak, respectively.
  english, czech %german, russian, slovak %% The additional keys allow
]{babel}        %% foreign texts to be typeset as follows:
%%
%%   \begin{otherlanguage}{german}  ... \end{otherlanguage}
%%   \begin{otherlanguage}{russian} ... \end{otherlanguage}
%%   \begin{otherlanguage}{czech}   ... \end{otherlanguage}
%%   \begin{otherlanguage}{slovak}  ... \end{otherlanguage}
%%
%% For non-Latin scripts, it may be necessary to load additional
%% fonts:
%\usepackage{paratype}
%\def\textrussian#1{{\usefont{T2A}{PTSerif-TLF}{m}{rm}#1}}

%%
%% The following section sets up the metadata of the thesis.
\thesissetup{
    date          = \the\year/\the\month/\the\day,
    university    = mu,
    faculty       = fi,
    type          = mgr,
    author        = Michal Hajas,
    gender        = m,
    advisor       = {RNDr. Petr Švenda, Ph.D.},
    title         = {Analysis of pseudo-random number generators based on lightweight cryptoprimitives},
    TeXtitle      = {Analysis of pseudo-random number generators based on lightweight cryptoprimitives},
    keywords      = {randomness testing, cryptanalysis, block functions, lightweight cryptography, pseudo-radnom number generators},
    TeXkeywords   = {randomness testing, cryptanalysis, block functions, lightweight cryptography, pseudo-radnom number generators},
}


\thesislong{abstract}{%
Abstract to be done
}

\thesislong{thanks}{%
Thank all.


\vspace*{11cm}\noindent{}\hspace*{-0.1cm}
Computational resources were supplied by the Ministry of Education, Youth and Sports of the Czech Republic under the Projects CESNET (Project No. LM2015042) and CERIT-Scientific Cloud (Project No. LM2015085) provided within the program Projects of Large Research, Development and Innovations Infrastructures.\\\\%
%
We also acknowledge the support of Czech Science Foundation, the project GA16-08565S.
}

%% The following section sets up the bibliography.
\usepackage{csquotes}
\usepackage[              %% When typesetting the bibliography, the
  backend=biber,          %% `numeric` style will be used for the
  style=numeric,          %% entries and the `numeric-comp` style
  citestyle=numeric-comp, %% for the references to the entries. The
  sorting=none,           %% entries will be sorted in cite order.
  sortlocale=auto         %% For more unformation about the available
]{biblatex}               %% `style`s and `citestyles`, see:
%% <http://mirrors.ctan.org/macros/latex/contrib/biblatex/doc/biblatex.pdf>.
\addbibresource{thesis.bib} %% The bibliograpic database within
                          %% the file `example.bib` will be used.
\usepackage{makeidx}      %% The `makeidx` package contains
\makeindex                %% helper commands for index typesetting.



%% These additional packages are used within the document:
\usepackage{paralist}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{url}
\usepackage{menukeys}

% cref, has to be loaded after hyperref
\usepackage{hyperref}
\usepackage[noabbrev,capitalise]{cleveref}
% for long equation wrap
\usepackage{wrapfig}
% figure captions
\usepackage{caption}
% subcaption for 2 figures in one
\usepackage{subcaption}
% H figures
\usepackage{float}

% tables
\usepackage{tabularx}
% colored cells (cellcolor)
\usepackage{colortbl}

% my colours
\usepackage{xcolor}

\usepackage{minted}

%% My own inputs:
% enabling new fonts support (nicer)
\usepackage{lmodern}
% better typeset of line ends and so (nicer)
\usepackage{microtype}

\thesisload{}

\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning}
\usetikzlibrary{decorations.pathreplacing}

% package to make bullet list nicer
\usepackage{enumitem}
\setitemize{noitemsep,topsep=3pt,parsep=3pt,partopsep=3pt}

% intendation
\usepackage{parskip}

% table colours
\newcommand{\fd}{\cellcolor{red!25}}
\newcommand{\fn}{}

% make captions italic
\usepackage[format=plain,
            font=it]{caption}

% Lubo's hack for margins
	\newcommand{\lmar}{3cm} % PC
	\newcommand{\rmar}{3cm} % PC
	\newcommand{\tmp}{3cm}  % PC

	%\newcommand{\lmar}{3.5cm} % Printed
	%\newcommand{\rmar}{2.5cm} % Printed
	%\newcommand{\tmp}{2.5cm}  % Printed


\usepackage[top=3cm, bottom=3.5cm, left=\lmar, right=\rmar]{geometry}

% Eliminates margins
\def\nomar{\list{}{\rightmargin-\tmp \leftmargin-\tmp}\item[]}
\let\endnomar=\endlist

% rotate figures
\usepackage{rotating}

% Table rotations
\usepackage{booktabs} % http://ctan.org/pkg/booktabs
\usepackage{xparse}   % http://ctan.org/pkg/xparse
% Rotation: \rot[<angle>][<width>]{<stuff>}
\NewDocumentCommand{\rot}{O{45} O{1em} m}{\makebox[#2][l]{\rotatebox{#1}{#3}}}%

% Rotates table cell
\newcolumntype{R}[1]{>{\begin{turn}{90}\begin{minipage}{#1}}l%
<{\end{minipage}\end{turn}}%
}


\begin{document}

% English indentation, vertical, not horizontal
\setlength{\parskip}{5pt}
\setlength{\parindent}{0pt}

%% We will define several mathematical sectioning commands.
\newtheorem{theorem}{Theorem}[section] %% The numbering of theorems
                               %% will be reset after each section.
\newtheorem{lemma}[theorem]{Lemma}     %% The numbering of lemmas
%\newtheorem{corr}[theorem]{Corrolary}  %% and corrolaries will
                                %% share the counter with theorems.
%\theoremstyle{definition}
%\newtheorem{definition}{Definition}
%\theoremstyle{remark}
%\newtheorem*{remark}{Remark}

\chapter{Introduction}
\label{chap:introduction}


\chapter{Theory}

\chapter{Introduction of CryptoStreams tool}
\label{chap:cryptostreams}

CryptoStreams tool is written in C++ language and is developed and maintained by team of people\footnote{The team of randomness testing involves following people: Radka Cieslarová, Michal Hajas, Dušan Klinec, Matúš Nemec, Jiří Novotný, Ľubomír Obrátil, Marek Sýs, Petr Švenda, Martin Ukrop and others.} at the Centre for Research on Cryptography and Security, Masaryk University~\cite{CryptoStreams}. The tool is used to generate output data streams from parametrized cryptographic functions. Each stream is configurable with resulting size and with several configuration options per individual streams such as seed, plaintext or key type. 

\section{History}

Initial implementation of CryptoStreams project was part of tool EACirc~\cite{EACirc} which is a tool for automatic randomness testing based on genetic programming. At that moment it served only as a provider of data to EACirc and was not possible to use it separately outside of this project. After some time we decided that CryptoStreams might be potentially interesting also as a separate tool. That is why EACirc-streams project was introduced in 2017 and then in 2018 EACirc sub-name was completely abandoned and project was renamed to nowadays name, CryptoStreams.

\section{Idea}

Main idea behind CryptoStreams is easy production of data from crypto-primitives which are somehow reduced in complexity, either by limiting rounds or by providing them input with bad randomness properties. The biggest advantage is easy incorporation of new functions to CryptoStreams and after this step it is trivial to obtain data which were produced by function in somehow limited scenario. After obtaining data it is possible to do any type of investigation over those data. For example in this thesis we will conduct statistical analysis with 7 statistical batteries of tests and also with tool called Booltest~\cite{booltest-secrypt2017}. Notice, that addition of new analysis tool requires no additional implementation on side of CryptoStreams.

\section{Content of CryptoStreams}

In this section we would like to present deeper details about what this tool provides. Very first cryptoprimitives which were added to CryptoStreams were candidates from SHA-3 and eStream competitions. Those additions were done by Ondrej Dubovec~\cite{Dubovec2012thesis} and Matej Prišťák~\cite{Pristak2012thesis} in 2012. Within those theses were added 34 hash functions and 27 stream ciphers. Another addition was done by Martin Ukrop in his master thesis~\cite{Ukrop2016thesis} regarding authenticated encryption systems from CAESAR competition~\cite{caesar-competition}. CryptoStreams also contains well known block ciphers like AES, DES etc. Block ciphers were added by Karel Kubíček~\cite{Kubicek2017thesis} and Tamás Rózsa~\cite{Rozsa2018thesis} in their theses. There are also lot of other cryptoprimitives added outside of thesis or papers.

% TODO: find citations for SHA-3 and eStream competition

Each output is generated by so called \textit{streams} which are producers of data. Each call produce chunk of data with configured size. Retrieving data from \textit{stream} in a loop and storing them results in data file with desired binary data. By configuring size of chunk and number of chunks to store it is possible to set size of resulting file. CryptoStreams contains following types of streams.

\begin{description}
	\item[\textit{Streams} outputing data of exact structure] which are mostly used as an input \textit{streams} such as plaintext or key. Those might be for example binary zero, binary one \textit{stream} or low hamming weight stream (small amount of ones) etc. Random (pseudo-random) streams also belong to this category. \cref{fig:exact-stream} shows example of schema of such \textit{stream}.
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.5\textwidth]{./images/pictures/exact-stream.png}
		\caption{Example of one call from exact \textit{stream}.}
		\label{fig:exact-stream}
	\end{figure}

	\item[Manipulating \textit{streams}] are configured with one or more inputs and manipulate them in some desired way. For example, \textit{repeating stream} is repeating one output specified number of times before generating new chunk of data from input \textit{stream}. Another example is \textit{tuple stream} that is getting more \textit{streams} as an input and for each call it returns chunk which contains data from each \textit{stream} concatenated together. Schema of this \textit{stream} is shown in \cref{fig:manipulating-stream}. Using tuple stream it is possible to receive data which consists of plaintexts followed by corresponding ciphertexts. 
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.7\textwidth]{./images/pictures/manipulating-stream.png}
		\caption{Example of one call from manipulating \textit{stream}, specifically \textit{tuple stream}. }
		\label{fig:manipulating-stream}
	\end{figure}
	
	\item[\textit{Streams} based on round-reduced cryptoprimitives.] Besides the round limitation it is also possible to configure them with various types of plaintext, key and initialization vectors inputs. \cref{fig:crypto-stream} shows schema of such stream which uses block cipher. The schema may be different for other cryptoprimitives, for example hash functions do not need key or iv as an input.
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.7\textwidth]{./images/pictures/cryptoprimitive-stream.png}
		\caption{Example of one call from cryptoprimitive \textit{stream}, where used function is block cipher.}
		\label{fig:crypto-stream}
	\end{figure}
	
	\item[\textit{Streams} based on pseudo-random number generators.] Those \textit{streams} are newly introduced as part of this thesis. It is not possible to round-reduce those types of generators, this means the only way how to weaken those generators are provide them seed with bad randomness properties. As \cref{fig:prng-streams} shows those streams are seeded in the beginning and then provide infinitely many output chunks. It is also possible to reseed generator after some specified number of \textit{chunks} generated.
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.7\textwidth]{./images/pictures/prng-stream.png}
		\caption{Example of three calls for new chunk with same seed from pseudo-random generator \textit{stream}.}
		\label{fig:prng-streams}
	\end{figure}
	
\end{description}

Notice that all inputs are in the form of another \textit{streams}, this means that it is possible to concatenate more streams together similarly like with unix pipes. Receiving \textit{stream} is deciding how many data and when will use from \textit{streams} on its input. For example if receiving \textit{stream} is ciphertext type it requests new plaintext for each chunk, but key may be generated only once in the beginning of generation. For better imagination how \textit{streams} really works, \cref{fig:config-schema} contains schema of whole run of CryptoStreams. The middle block is the most important one. It is \textit{cryptoprimitive stream} and on its input it has 3 \textit{exact streams}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\textwidth]{./images/pictures/config-schema.png}
	\caption{Schema of CryptoStreams configuration from \cref{listing:json-example}. More information about specific \textit{streams} within this picture can be found in \cref{subsec:configuration} }
	\label{fig:config-schema}
\end{figure}


\subsection{Configuration}
\label{subsec:configuration}

All necessary configuration within one run is achieved by \texttt{JSON} file. Example of such configuration file can be found in \cref{listing:json-example} which will result in file of size 8GB, which contains output from function CHASKEY limited to 5 rounds. Key is generated pseudo-randomly using PCG32~\cite{pcgGen} in the beginning of run and then used for generation of each output chunk. \textit{Counter stream} is used as a plaintext. Schema of this configuration is shown in \cref{fig:config-schema}. 

Whole run of generator is deterministic as it is using pseudo-random generator. That is why configuration contains also seed. All values which are generated pseudo-randomly are based on this seed, in other words if you run CryptoStreams twice with same configuration the resulting files will be equal. Notice that resulting file size is derived from \textit{chunk size} in Bytes and number of \textit{chunks}. All possible options how to configure CryptoStreams can be found in project documentation~\cite{CryptoStreams-wiki}.

\begin{listing}
	\begin{minted}[frame=single,
	framesep=3mm,
	linenos=true,
	xleftmargin=21pt,
	tabsize=4]{js}
	{
		"tv_count": 500000000,
		"file_name": "CHASKEY_r05_b16.bin",
		"seed": "1fe40505e131963c",
		"notes": "generated by generator.py",
		"tv_size": 16,
		"stream": {
			"init_frequency": "only_once",
			"block_size": 16,
			"key": {"type": "pcg32_stream"},
			"round": 5,
			"plaintext": {"type": "counter"},
			"iv": {"type": "false_stream"},
			"iv_size": 16,
			"key_size": 16,
			"type": "block",
			"algorithm": "CHASKEY"
		}
	}
	\end{minted}
	\caption{Example of \texttt{JSON} configuration of tool CryptoStreams.}
	\label{listing:json-example}
\end{listing}

\subsection{Testing of streams}

Our statistical analysis relies on the fact that data which come from CryptoStreams are correct and truly come from cryptoprimitives. That is why it is very important to have proof that our implementation of each cryptoprimitive is correct one. To have this proof we introduced testsuite which contains various number of tests per individual \textit{stream}. Since CryptoStreams contains huge amount of \textit{streams}, we have not added tests for all of them, instead of that we added tests for those which are used most frequently. It is also required to have tests in order to add new \textit{stream} into CryptoStreams. All results in this thesis are based on \textit{streams} which are properly tested.

Regarding implementation details we are using Google Test~\footnote{\url{https://github.com/google/googletest}} framework as testing backend. Moreover we are using tool Travis CI\footnote{\url{https://travis-ci.org}} for continuous integration. It means new changes are not approved unless it passes all tests including newly added tests. 

There are two things which are important to test, first one is function itself, source code which is included within CryptoStreams. The other thing is CryptoStreams superstructure which encapsulates all cryptoprimitives and functions into one interface. Each type of \textit{streams} have different testing scenarios.

\begin{description}
	\item[Block ciphers \textit{streams}] are tested with test vectors in both directions, encrypt and decrypt. Also, both mentioned layers are tested. All those tests are testing function only in full number of rounds as we were not able to find test vectors for round limited version. For lightweight cryptoprimitives based \textit{streams} we added also \textit{encrypt-decrypt} test for all supported rounds. This test is testing whether encryption of plaintext followed by decryption results with inputted plaintext. However, this test does not work for all added functions, the reasons are summarized in \cref{sec:added_lightweight_crypto}.
	
	\item[Hash functions \textit{streams}] are tested with test vectors in full number of rounds. Both low level function and CryptoStreams superstructure are tested.
	
	\item[Stream ciphers \textit{streams}] are tested similarly as block ciphers except for encrypt-decrypt test for round reduced versions.
	
	\item[Pseudo-random generators \textit{streams}] are quite hard to test, we have not found any test vectors. Nonetheless, we at least added test for linear generator, we tried to implement succession of numbers in tests and then compare whether we are getting same numbers from generator implementation. 
	
	\item[Other \textit{streams}] exact or manipulating are quite easy to test as we know how exactly should output look like.
	 
\end{description}


\section{Conducted experiments}

The experiment we conducted was based on testing of randomness provided by function in some extreme scenario. Either by limitation of function rounds if it is available or by providing bad input. We tested those scenarios.

\begin{description}
	\item[Special type of input,] mostly with some bad randomness properties, is provided to functions and statistical analysis is conducted where results are compared with random or other special inputs. For purposes of this thesis we used following types of inputs.
	\begin{enumerate}
		\item Counter \textit{stream} is such \textit{stream} in which each chunk is addition of one to previous chunk in number representation.
		\item Low hamming weight \textit{stream} returns outputs with least count of ones it is possible. Starting with all zeroes. Then only binary one on each position, two binary ones etc.
		\item Strict avalanche criterion is a type of \textit{stream} in which first chunk is randomly generated and every next call is just previous chunk with one flipped bit.
	\end{enumerate}

	\item[Round reduction.] Almost each cryptographic function is build so that it performs very same sequence of operations multiple times, mostly in a loop. Number of times sequence should be performed is denoted by term \textit{number of rounds}. For example, AES~\cite{FIPS-197} has recommended number of rounds 10, 12 or 14 based on key length as you can see in \cref{fig:fips197-rounds}. Each round in AES consists of \textit{SubBytes, ShiftRows, MixColumns, AddRoundKey} operations.
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.9\textwidth]{./images/pictures/FIPS197-Nr-table.png}
		\caption{Table of rounds based on key size taken from~\cite{FIPS-197}, word size is 32 bits.}
		\label{fig:fips197-rounds}
	\end{figure}

	Creators of each cryptographic function specify how many rounds should be used in order to have reasonable security, this number is called \textit{full number of rounds}. This number should be determined by conducting different cryptanalysis of function limited to several number of rounds. Important indicator during this process is also \textit{security margin}. Security margin denotes rate between round vulnerable to some cryptanalysis attack and full number of rounds. For example authors of AES were unable to find any practical shortcut attack (any attack which is more efficient than exhaustive key search) for more than 6 rounds for AES with key length 128 bits. That is why they recommend to use 10 rounds with 4 as a security margin \cite{daemen1999aes}. Notice that \textit{security margin} is not some general notion for whole function, instead of that it is just kind of expression of resistance against corresponding cryptanalysis technique or attack.
	
	In this thesis we will denote security margin based on randomness properties of outputs from functions reduced to rounds.
	
	\item[Plaintext ciphertext stream] produce pairs of input and output to function. With statistical testing performed on such output, it is possible to investigate dependency between plaintext and ciphertext. However we need to be careful with deciding what input we will choose since it is part of output it must have perfect randomness properties otherwise it may cause some interference in testing result.

\end{description}

\subsection{Testing with statistical batteries of tests}
\subsection{Testing with BoolTest}

\section{Investigated pseudo-random generators}

In this section we will present all functions which were added to CryptoStreams and tested with statistical batteries and Booltest~\cite{booltest-secrypt2017}.

\subsection{Pure pseudo-random generators}

First part of this thesis is addition to CryptoStreams and analysis of pure (do not use any crypto primitive to generate pseudo-randomness) pseudo-random number generators. This component is quite small as we added together only six generators. The reason why we added so small amount of generator is that we have not found any source of generators which would offer generators in a way it would be easy to incorporate to CryptoStream.

First source of generators was TesU01~\cite{l2007testu01} project. It contains big amount of generators, but they offer just implementation without parameters set up. So we needed to find out those parameters ourselves and it was quite hard to choose correctly. We have taken over 3 generators and also included some basic tests. All generators are presented in \cite{LEcuyer07testu01}.
\begin{description}
	\item[Linear congruential generator.]  This generator has formula shown in \cref{lemma:lcg} \cite{LEcuyer07testu01}. Chosen parameters are taken from \cite{L-Ecuyer:LCG} and values are $a = 4645906587823291368$, $c = 0$ and $m = 9223372036854775783$. We tried to choose as big parameter \textit{m} as possible because generator is returning values modulo this parameter, this means outputting values are always less than this number. Since returning value frome generator is always 8 Bytes big, number $ 9223372036854775783 $ have few upper bits binary zeroes, also outputting value will always have those bits binary zero. This is why we needed to cut those bits in order to not have some interference caused by this in statistical tests. This is the main reason, why we have not added more generators in this thesis because it requires too much configuration and testing to be sure the generators are working properly.
	
	\item[Multiple recursive generator.] Another linear generator, which is based on very similar principle as LCG, with the difference that it combines data from more than one previous run. The formula is shown in \cref{lemma:mrg}. Values of parameters are $ k = 2 $, $ a_{1} = 2975962250 $, $ a_{2} = 2909704450 $ and $ m = 9223372036854775783 $ \cite{L_Ecuyer:MRG}. And we needed to cut starting binary zeroes too.
	
	\item[Xorshift generator.] The generator is based on \textit{xor} and \textit{shift} operations~\cite{RePEc:jss:jstsof:v:008:i14}. We have chosen version which is created by function \texttt{uxorshift\_CreateXorshift13}, more information in \cite{LEcuyer07testu01} on page 50. 
\end{description}

Three of those six added generators are from standard library, namely \textit{\textbf{lcg}}~\footnote{\url{ https://en.cppreference.com/w/cpp/numeric/random/linear\_congruential\_engine}}, \textbf{\textit{mersenne twister}}~\footnote{\url{https://en.cppreference.com/w/cpp/numeric/random/mersenne\_twister\_engine}} and \textbf{\textit{substract with carry}}~\footnote{\url{https://en.cppreference.com/w/cpp/numeric/random/subtract\_with\_carry_engine}}.

\begin{lemma}

	Formula for linear congruential generator (LCG) is
	\begin{equation}
	x_{n+1} = \left( a \times x_n + c \right)~~\bmod~~m
	\end{equation}
	Where \textit{a, c, m} are parameters of generator hardcoded within CryptoStreams, $X_{n-1}$ is previous value and $X_{0}$ is seed. 
	
	\label{lemma:lcg}
\end{lemma}

\begin{lemma}
	
	Formula for Multiple recursive generator (MRG) is
	\begin{equation}
	x_{n} = \left(a_{1} \times x_{\left(n-1\right)} + . . . + a_{k} \times x_{\left(n-k\right)}\right)~~\bmod~~m
	\end{equation}
	Where \textit{k, $a_{1} .. a_{k}$ and m} are parameters of generator hardcoded within CryptoStreams, $X_{n-l}$ is output of run $n-l$ where $n$ is current run and $l$ is number between $1$ and $k$. Seed represents initial values of $X_{0}$ to $X_{k}$ 
	
	\label{lemma:mrg}
\end{lemma}
	

We do not round reduce those generators, because the implementation do not provide it. Hence we only weakened them with seed with bad randomness properties.

\subsection{Generators based on lightweight cryptoprimitives}
\label{sec:added_lightweight_crypto}

The other part contains block ciphers taken over from project FELICS~\cite{dinu2015felics} developed by Daniel Dinu and his group at University of Luxembourg. This project is conducting performance analysis of lightweight functions that are intended for embedded devices. We have taken over only C++ implementation of functions, as we were not interested in implementations optimized for other architectures. Also we needed to implement round reduction of functions ourselves as the project contained only full round implementation. However, provision of round reduction was not hard, mostly functions were prepared with round reduction in mind and we needed to only replace constant in loop with variable which is configurable from CryptoStreams. 

Besides the main loop, functions mostly contain also key scheduling, initial and final part. Key scheduling is taking care of the creation of round key based on a encryption key. Initial and final part serves for initialization and finalization of process. We do not round-reduce any of those parts as we wanted to avoid some memory problems like uninitialized or wrongly cleaned memory.

\cref{table:list-of-investigated functions} contains all investigated functions including some basic information about them. Our intention was also adding two test scenarios for each added function. First scenario is testing correct implementation with test vectors. FELICS project contains test vectors for each function, so we used those. The aim of the second test scenario is testing round reduction by doing encryption followed by decryption with function limited to all possible number of rounds. However, we were not able to make this scenario work for each function. Function without this test are marked with \textit{no} in last column in \cref{table:list-of-investigated functions}. The main reason why we were not able to make this test work is that FELICS project is not build to support it and we were not able to modify it in a way it would work. This may be caused also by non reducing of key scheduling, initial and final parts. However, the most important is that the test is passing in full round version of function and it passes for all functions. We do not consider round reduction broken in case the test does not pass.

\begin{table}[t]
	\centering
	\begin{tabular}{c|c c c c}
		\textbf{\large Function} & \textbf{\large Round} & \textbf{\large Block size} & \textbf{\large Key size} & \textbf{\large Encrypt Decrypt test}\\ \hline
		Chaskey~\cite{cryptoeprint:2014:386}				& 16	& 16	& 16	& yes 	\\ \hline
		Fantomas~\cite{grosso2014ls}						& 12	& 16	& 16	& yes 	\\ \hline
		HIGHT~\cite{10.1007/11894063_4}						& 32	& 8		& 16	& no 	\\ \hline
		LBlock~\cite{10.1007/978-3-642-21554-4_19}			& 32	& 8		& 10	& no \\ \hline
		LEA~\cite{Hong2013LEAA1}							& 24	& 16	& 16	& no \\ \hline
		LED~\cite{Guo:2011:LBC:2044928.2044958}				& 48	& 8		& 10	& yes \\ \hline
		Piccolo~\cite{10.1007/978-3-642-23951-9_23}			& 25	& 8		& 10	& yes \\ \hline
		PRIDE~\cite{10.1007/978-3-662-44371-2_4}			& 20	& 8		& 16	& no  \\ \hline
		PRINCE~\cite{10.1007/978-3-642-34961-4_14}			& 12	& 8		& 16	& yes \\ \hline
		RC5-20~\cite{10.1007/3-540-60590-8_7}				& 20	& 8		& 10	& yes \\ \hline
		RECTANGLE-K80~\cite{Zhang2015}						& 25	& 8		& 16	& no \\ \hline
		RECTANGLE-K128~\cite{Zhang2015}						& 25	& 8		& 16	& no \\ \hline
		RoadRunneR-K80~\cite{10.1007/978-3-319-29078-2_4}	& 10	& 8		& 10	& yes \\ \hline
		RoadRunneR-K128~\cite{10.1007/978-3-319-29078-2_4}	& 12	& 8		& 16	& yes \\ \hline
		Robin~\cite{grosso2014ls}							& 16	& 16	& 16	& yes \\ \hline
		RobinStar~\cite{grosso2014ls}						& 16	& 16	& 16	& yes \\ \hline
		SPARX-B64~\cite{10.1007/978-3-662-53887-6_18}		& 8		& 8		& 16	& yes \\ \hline
		SPARX-B128~\cite{10.1007/978-3-662-53887-6_18}		& 8		& 16	& 16	& yes \\ \hline
		TWINE~\cite{twine}									& 35	& 8		& 10	& yes \\ \hline
		
		
	\end{tabular}
	\caption{List of all investigated functions, where sizes are given in Bytes. Including information whether encrypt decrypt test passed.}
	\label{table:list-of-investigated functions}
\end{table}



\chapter{Results of evaluation of statistical randomness properties}


%%bibliography

\printbibliography[heading=bibintoc] %% Print the bibliography.

\appendix{}

\end{document}
