%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% I, the copyright holder of this work, release this of into the
%% public domain. This applies worldwide. In some countries this may
%% not be legally possible; if so: I grant anyone the right to use
%% this work for any purpose, without any conditions, unless such
%% conditions are required by law.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[
    %twoside,   % Printed version
    %printed,   % Printed version
    digital,    % PC version
    oneside,    % PC version
    color,
    11pt,
    nocover,
    notable,
    nolof,
    nolot,
    final
  %% More options are listed in the user guide at
  %% <http://mirrors.ctan.org/macros/latex/contrib/fithesis/guide/mu/fi.pdf>.
]{fithesis3}
%% The following section sets up the locales used in the thesis.
\usepackage[resetfonts]{cmap} %% We need to load the a T2A font encoding
%\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}  % T2a commented %% to use the Cyrillic fonts with Russian texts.
\usepackage[
  main=english, %% By using `czech` or `slovak` as the main locale
                %% instead of `english`, you can typeset the thesis
                %% in either Czech or Slovak, respectively.
  english, czech %german, russian, slovak %% The additional keys allow
]{babel}        %% foreign texts to be typeset as follows:
%%
%%   \begin{otherlanguage}{german}  ... \end{otherlanguage}
%%   \begin{otherlanguage}{russian} ... \end{otherlanguage}
%%   \begin{otherlanguage}{czech}   ... \end{otherlanguage}
%%   \begin{otherlanguage}{slovak}  ... \end{otherlanguage}
%%
%% For non-Latin scripts, it may be necessary to load additional
%% fonts:
%\usepackage{paratype}
%\def\textrussian#1{{\usefont{T2A}{PTSerif-TLF}{m}{rm}#1}}

%%
%% The following section sets up the metadata of the thesis.
\thesissetup{
    date          = \the\year/\the\month/\the\day,
    university    = mu,
    faculty       = fi,
    type          = mgr,
    author        = Michal Hajas,
    gender        = m,
    advisor       = {RNDr. Petr Švenda, Ph.D.},
    title         = {Analysis of pseudo-random number generators based on lightweight cryptoprimitives},
    TeXtitle      = {Analysis of pseudo-random number generators based on lightweight cryptoprimitives},
    keywords      = {randomness testing, cryptanalysis, block functions, lightweight cryptography, pseudo-radnom number generators},
    TeXkeywords   = {randomness testing, cryptanalysis, block functions, lightweight cryptography, pseudo-radnom number generators},
}


\thesislong{abstract}{%
Abstract to be done
}

\thesislong{thanks}{%
Thank all.


\vspace*{11cm}\noindent{}\hspace*{-0.1cm}
Computational resources were supplied by the Ministry of Education, Youth and Sports of the Czech Republic under the Projects CESNET (Project No. LM2015042) and CERIT-Scientific Cloud (Project No. LM2015085) provided within the program Projects of Large Research, Development and Innovations Infrastructures.\\\\%
%
We also acknowledge the support of Czech Science Foundation, the project GA16-08565S.
}

%% The following section sets up the bibliography.
\usepackage{csquotes}
\usepackage[              %% When typesetting the bibliography, the
  backend=biber,          %% `numeric` style will be used for the
  style=numeric,          %% entries and the `numeric-comp` style
  citestyle=numeric-comp, %% for the references to the entries. The
  sorting=none,           %% entries will be sorted in cite order.
  sortlocale=auto         %% For more unformation about the available
]{biblatex}               %% `style`s and `citestyles`, see:
%% <http://mirrors.ctan.org/macros/latex/contrib/biblatex/doc/biblatex.pdf>.
\addbibresource{thesis.bib} %% The bibliograpic database within
                          %% the file `example.bib` will be used.
\usepackage{makeidx}      %% The `makeidx` package contains
\makeindex                %% helper commands for index typesetting.



%% These additional packages are used within the document:
\usepackage{paralist}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{url}
\usepackage{menukeys}

% cref, has to be loaded after hyperref
\usepackage{hyperref}
\usepackage[noabbrev,capitalise]{cleveref}
% for long equation wrap
\usepackage{wrapfig}
% figure captions
\usepackage{caption}
% subcaption for 2 figures in one
\usepackage{subcaption}
% H figures
\usepackage{float}

% tables
\usepackage{tabularx}
% colored cells (cellcolor)
\usepackage{colortbl}

% my colours
\usepackage{xcolor}

\usepackage{minted}

%% My own inputs:
% enabling new fonts support (nicer)
\usepackage{lmodern}
% better typeset of line ends and so (nicer)
\usepackage{microtype}

\thesisload{}

\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning}
\usetikzlibrary{decorations.pathreplacing}

% package to make bullet list nicer
\usepackage{enumitem}
\setitemize{noitemsep,topsep=3pt,parsep=3pt,partopsep=3pt}

% intendation
\usepackage{parskip}

% table colours
\newcommand{\fd}{\cellcolor{red!25}}
\newcommand{\fn}{}

% make captions italic
\usepackage[format=plain,
            font=it]{caption}

% Lubo's hack for margins
	\newcommand{\lmar}{3cm} % PC
	\newcommand{\rmar}{3cm} % PC
	\newcommand{\tmp}{3cm}  % PC

	%\newcommand{\lmar}{3.5cm} % Printed
	%\newcommand{\rmar}{2.5cm} % Printed
	%\newcommand{\tmp}{2.5cm}  % Printed


\usepackage[top=3cm, bottom=3.5cm, left=\lmar, right=\rmar]{geometry}

% Eliminates margins
\def\nomar{\list{}{\rightmargin-\tmp \leftmargin-\tmp}\item[]}
\let\endnomar=\endlist

% rotate figures
\usepackage{rotating}

% Table rotations
\usepackage{booktabs} % http://ctan.org/pkg/booktabs
\usepackage{xparse}   % http://ctan.org/pkg/xparse
% Rotation: \rot[<angle>][<width>]{<stuff>}
\NewDocumentCommand{\rot}{O{45} O{1em} m}{\makebox[#2][l]{\rotatebox{#1}{#3}}}%

% Rotates table cell
\newcolumntype{R}[1]{>{\begin{turn}{90}\begin{minipage}{#1}}l%
<{\end{minipage}\end{turn}}%
}


\begin{document}

% English indentation, vertical, not horizontal
\setlength{\parskip}{5pt}
\setlength{\parindent}{0pt}

%% We will define several mathematical sectioning commands.
%\newtheorem{theorem}{Theorem}[section] %% The numbering of theorems
                               %% will be reset after each section.
%\newtheorem{lemma}[theorem]{Lemma}     %% The numbering of lemmas
%\newtheorem{corr}[theorem]{Corrolary}  %% and corrolaries will
                                %% share the counter with theorems.
%\theoremstyle{definition}
%\newtheorem{definition}{Definition}
%\theoremstyle{remark}
%\newtheorem*{remark}{Remark}

\chapter{Introduction}
\label{chap:introduction}


\chapter{Theory}

\chapter{Introduction of CryptoStreams tool}
\label{chap:cryptostreams}

CryptoStreams tool is written in C++ language and is developed and maintained by team of people\footnote{The team of randomness testing involves following people: Radka Cieslarová, Michal Hajas, Dušan Klinec, Matúš Nemec, Jiří Novotný, Ľubomír Obrátil, Marek Sýs, Petr Švenda, Martin Ukrop and others.} at the Centre for Research on Cryptography and Security, Masaryk University~\cite{CryptoStreams}. The tool is used to generate output data streams from parametrized cryptographic functions. Each stream is configurable with resulting size and with several configuration options per individual streams such as seed, plaintext or key type. 

\section{History}

Initial implementation of CryptoStreams project was part of tool EACirc~\cite{EACirc} which is a tool for automatic randomness testing based on genetic programming. At that moment it served only as a provider of data to EACirc and was not possible to use it separately outside of this project. After some time we decided that CryptoStreams might be potentially interesting also as a separate tool. That is why EACirc-streams project was introduced in 2017 and then in 2018 EACirc sub-name was completely abandoned and project was renamed to nowadays name, CryptoStreams.

\section{Idea}

Main idea behind CryptoStreams is easy production of data from crypto-primitives which are somehow reduced in complexity, either by limiting rounds or by providing them input with bad randomness properties. The biggest advantage is easy incorporation of new functions to CryptoStreams and after this step it is trivial to obtain data which were produced by function in somehow limited scenario. After obtaining data it is possible to do any type of investigation over those data. For example in this thesis we will conduct statistical analysis with 7 statistical batteries of tests and also with tool called Booltest~\cite{booltest-secrypt2017}. Notice, that addition of new analysis tool requires no additional implementation on side of CryptoStreams.

\section{Content of CryptoStreams}

In this section we would like to present deeper details about what this tool provides. Very first cryptoprimitives which were added to CryptoStreams were candidates from SHA-3 and eStream competitions. Those additions were done by Ondrej Dubovec~\cite{Dubovec2012thesis} and Matej Prišťák~\cite{Pristak2012thesis} in 2012. Within those theses were added 34 hash functions and 27 stream ciphers. Another addition was done by Martin Ukrop in his master thesis~\cite{Ukrop2016thesis} regarding authenticated encryption systems from CAESAR competition~\cite{caesar-competition}. CryptoStreams also contains well known block ciphers like AES, DES etc. Block ciphers were added by Karel Kubíček~\cite{Kubicek2017thesis} and Tamás Rózsa~\cite{Rozsa2018thesis} in their theses. There are also lot of other cryptoprimitives added outside of thesis or papers.

% TODO: find citations for SHA-3 and eStream competition

Each output is generated by so called \textit{streams} which are producers of data. Each call produce chunk of data with configured size. Retrieving data from \textit{stream} in a loop and storing them results in data file with desired binary data. By configuring size of chunk and number of chunks to store it is possible to set size of resulting file. CryptoStreams contains following types of streams.

\begin{description}
	\item[Streams outputing data of exact structure] which are mostly used as an input \textit{streams} such as plaintext or key. Those might be for example binary zero, binary one \textit{stream} or low hamming weight stream (small amount of ones) etc. Random (pseudo-random) streams also belong to this category. \cref{fig:exact-stream} shows example of schema of such \textit{stream}.
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.5\textwidth]{./images/pictures/exact-stream.png}
		\caption{Example of one call from exact \textit{stream}.}
		\label{fig:exact-stream}
	\end{figure}
	
	\item[Streams based on round-reduced cryptoprimitives.] Besides the round limitation it is also possible to configure them with various types of plaintext, key and initialization vectors inputs. \cref{fig:crypto-stream} shows schema of such stream which uses block cipher. The schema may be different for other cryptoprimitives, for example hash functions do not need key or iv as an input.
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.7\textwidth]{./images/pictures/cryptoprimitive-stream.png}
		\caption{Example of one call from cryptoprimitive \textit{stream}, where used function is block cipher.}
		\label{fig:crypto-stream}
	\end{figure}
	
	\item[Manipulating streams] are configured with one or more inputs and manipulate them in some desired way. For example, \textit{repeating stream} is repeating one output specified number of times before generating new chunk of data from input \textit{stream}. Another example is \textit{tuple stream} that is getting more \textit{streams} as an input and for each call it returns chunk which contains data from each \textit{stream} concatenated together. Schema of this \textit{stream} is shown in \cref{fig:manipulating-stream}. Using tuple stream it is possible to receive data which consists of plaintexts followed by corresponding ciphertexts. 
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.7\textwidth]{./images/pictures/manipulating-stream.png}
		\caption{Example of one call from manipulating \textit{stream}, specifically \textit{tuple stream}. }
		\label{fig:manipulating-stream}
	\end{figure}

\end{description}

Notice that all inputs are in the form of another \textit{streams}, this means that it is possible to concatenate more streams together similarly like with unix pipes. Receiving \textit{stream} is deciding how many data and when will use from \textit{streams} on its input. For example if receiving \textit{stream} is ciphertext type it requests new plaintext for each chunk, but key may be generated only once in the beginning of generation. For better imagination how \textit{streams} really works, \cref{fig:config-schema} contains schema of whole run of CryptoStreams. The middle block is the most important one. It is \textit{cryptoprimitive stream} and on its input it has 3 \textit{exact streams}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\textwidth]{./images/pictures/config-schema.png}
	\caption{Schema of CryptoStreams configuration from \cref{listing:json-example}. More information about specific \textit{streams} within this picture can be found in \cref{subsec:configuration} }
	\label{fig:config-schema}
\end{figure}


\subsection{Configuration}
\label{subsec:configuration}

All necessary configuration within one run is achieved by \texttt{JSON} file. Example of such configuration file can be found in \cref{listing:json-example} which will result in file of size 8GB, which contains output from function CHASKEY limited to 5 rounds. Key is generated pseudo randomly using PCG32~\cite{pcgGen} in the beginning of run and then used for generation of each test vector. \textit{Counter stream} is used as a plaintext. Schema of this configuration is shown in \cref{fig:config-schema}. 

Whole run of generator is deterministic as it is using pseudo-random generator. That is why configuration contains also seed. All values which are generated pseudo-randomly are based on this seed, in other words if you run CryptoStreams twice with same configuration the resulting files will be equal. Notice that resulting file size is derived from \textit{chunk size} in Bytes and number of \textit{chunks}. All possible options how to configure CryptoStreams can be found in project documentation~\cite{CryptoStreams-wiki}.

\begin{listing}
	\begin{minted}[frame=single,
	framesep=3mm,
	linenos=true,
	xleftmargin=21pt,
	tabsize=4]{js}
	{
		"tv_count": 500000000,
		"file_name": "CHASKEY_r05_b16.bin",
		"seed": "1fe40505e131963c",
		"notes": "generated by generator.py",
		"tv_size": 16,
		"stream": {
			"init_frequency": "only_once",
			"block_size": 16,
			"key": {"type": "pcg32_stream"},
			"round": 5,
			"plaintext": {"type": "counter"},
			"iv": {"type": "false_stream"},
			"iv_size": 16,
			"key_size": 16,
			"type": "block",
			"algorithm": "CHASKEY"
		}
	}
	\end{minted}
	\caption{Example of \texttt{JSON} configuration of tool CryptoStreams.}
	\label{listing:json-example}
\end{listing}

\subsection{Testing of streams}

Our statistical analysis relies on the fact that data which come from CryptoStreams are correct and truly come from cryptoprimitives. That is why it is very important to have proof that our implementation of each cryptoprimitive is correct one. To have this proof we introduced testsuite which contains various number of tests per individual \textit{stream}. We have not added tests for each function which is contained in CryptoStreams, instead of that we added them for functions which are used most frequently. It is also required to have tests in order to add new function into CryptoStreams. All results in this thesis are based on streams which are properly tested.

Regarding implementation details we are using Google Test~\footnote{\url{https://github.com/google/googletest}} framework as testing backend. Moreover we are using tool Travis CI\footnote{\url{https://travis-ci.org}} for continuous integration. It means the new change is not approved unless it passes all tests including newly added tests. 

There are two things which are important to test, first one is function itself, source code which is included within CryptoStreams. The other thing is CryptoStreams superstructure which encapsulates all cryptoprimitives into one interface. All \textit{streams} are interchangeable and only difference is in configuration. 


\section{Test with statistical batteries/ RTT}

\section{Conducted experiments}

There are more ways how we reduce functions so that we find out where are theirs limitations. 

\begin{description}
	\item[Special type of input,] mostly with some bad randomness properties, is provided to functions and then results are compared with random or other special inputs. For purposes of this thesis we used following types of inputs.
	\begin{enumerate}
		\item Counter stream is a stream in which each test-vector is addition of one to previous test-vector in number representation.
		\item Low hamming weight stream returns outputs with least count of ones it is possible. Starting with all zeroes. Then only binary one on each position etc.
		\item Strict avalanche criterion is a type of stream in which first test-vector is randomly generated and every next call is just previous test-vector with one flipped bit.
	\end{enumerate}


	\item[Round reduction.] Almost each cryptographic function is build so that it performs very same sequence of operations multiple times, mostly in a loop. Number of times sequence should be performed is denoted by term \textit{number of rounds}. For example, AES~\cite{FIPS-197} has recommended number of rounds 10, 12 or 14 based on key length as you can see in \cref{fig:fips197-rounds}. Each round in AES consists of \textit{SubBytes, ShiftRows, MixColumns, AddRoundKey} operations.
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.9\textwidth]{./images/pictures/FIPS197-Nr-table.png}
		\caption{Table of rounds based on key size taken from~\cite{FIPS-197}, word size is 32 bits.}
		\label{fig:fips197-rounds}
	\end{figure}

	Creators of each cryptographic function specify how many rounds should be used in order to have reasonable security, this number is called \textit{full number of rounds}. This number should be determined by conducting different cryptanalysis of function limited to several number of rounds. Important indicator during this process is also \textit{security margin}. Security margin denotes rate between round vulnerable to some cryptanalysis attack and full number of rounds. For example authors of AES were unable to find any practical shortcut attack (any attack which is more efficient than exhaustive key search) for more than 6 rounds for AES with key length 128 bits. That is why they recommend to use ten rounds with four as a security margin \cite{daemen1999aes}. Notice that \textit{security margin} is not some general notion for whole function, instead of that it is just kind of expression of resistance against corresponding cryptanalysis technique or attack.
	
	In this thesis we will denote security margin based on randomness properties of outputs from functions reduced to rounds.
	
% TODO: Find out security margin literature
	\item[Plaintext ciphertext stream] produce pairs of input and output to function. With statistical testing performed on such output, it is possible to investigate dependency between plaintext and ciphertext. However we need to be careful with deciding what input we will choose since it is part of output it must have perfect randomness properties otherwise it may cause some interference in testing result.

\end{description}

\section{Investigated pseudo-random generators}

In this section we will present all functions which were added to CryptoStreams and tested with statistical batteries and Booltest~\cite{booltest-secrypt2017}.

\subsection{Pure pseudo-random generators}

First part of this thesis is addition to CryptoStreams and analysis of pure (do not use any crypto primitive to generate pseudo-randomness) pseudo-random number generators. This component is quite small as we added together only six generators. The reason why we added so small amount of generator is that we have not found any source of generators which would be easy to add to CryptoStreams. Pseudo-random generator requires except for seed also some additional parameters and we had problems with setting those parameters correctly. Three of those six added generators are from standard library, namely \textit{\textbf{lcg}}~\footnote{\url{ https://en.cppreference.com/w/cpp/numeric/random/linear\_congruential\_engine}}, \textbf{\textit{mersenne twister}}~\footnote{\url{https://en.cppreference.com/w/cpp/numeric/random/mersenne\_twister\_engine}} and \textbf{\textit{substract with carry}}~\footnote{\url{https://en.cppreference.com/w/cpp/numeric/random/subtract\_with\_carry_engine}}. The other three are from TesU01~\cite{l2007testu01} project, namely \textbf{\textit{lcg}}, \textbf{\textit{mrg}} and \textbf{\textit{xorshift}}, more information in user guide~\cite{LEcuyer07testu01}. Pseudo-random generators were added including some basic tests.

We do not round reduce those generators, because the implementation do not provide it. Hence we only weakened them with seed with bad randomness properties.

\subsection{Generators based on lightweight cryptoprimitives}

The other part contains block ciphers taken over from project FELICS~\cite{dinu2015felics} developed by Daniel Dinu and his group at University of Luxembourg. This project is conducting performance analysis of lightweight functions that are intended for embedded devices. We have taken over only C++ implementation of functions, as we were not interested in implementations optimized for other architectures. Also we needed to implement round reduction of functions ourselves as the project contained only full round implementation. However, provision of round reduction was not hard, mostly functions were prepared with round reduction in mind and we needed to only replace constant in loop with variable which is configurable from CryptoStreams. 

Besides the main loop, functions mostly contain also key scheduling, initial and final part. Key scheduling is taking care of the creation of round key based on a encryption key. Initial and final part serves for initialization and finalization of process. We do not round-reduce any of those parts as we wanted to avoid some memory problems like uninitialized or wrongly cleaned memory.

\cref{table:list-of-investigated functions} contains all investigated functions including some basic information about them. Our intention was also adding two test scenarios for each added function. First scenario is testing correct implementation with test vectors. FELICS project contains test vectors for each function, so we used those. The aim of the second test scenario is testing round reduction by doing encryption followed by decryption with function limited to all possible number of rounds. However, we were not able to make this scenario work for each function. Function without this test are marked with \textit{no} in last column in \cref{table:list-of-investigated functions}. The main reason why we were not able to make this test work is that FELICS project is not build to support it and we were not able to modify it in a way it would work. This may be caused also by non reducing of key scheduling, initial and final parts. However, the most important is that the test is passing in full round version of function and it passes for all functions. We do not consider round reduction broken in case the test does not pass.

\begin{table}[t]
	\centering
	\begin{tabular}{c|c c c c}
		\textbf{\large Function} & \textbf{\large Round} & \textbf{\large Block size} & \textbf{\large Key size} & \textbf{\large Encrypt Decrypt test}\\ \hline
		Chaskey~\cite{cryptoeprint:2014:386}				& 16	& 16	& 16	& yes 	\\ \hline
		Fantomas~\cite{grosso2014ls}						& 12	& 16	& 16	& yes 	\\ \hline
		HIGHT~\cite{10.1007/11894063_4}						& 32	& 8		& 16	& no 	\\ \hline
		LBlock~\cite{10.1007/978-3-642-21554-4_19}			& 32	& 8		& 10	& no \\ \hline
		LEA~\cite{Hong2013LEAA1}							& 24	& 16	& 16	& no \\ \hline
		LED~\cite{Guo:2011:LBC:2044928.2044958}				& 48	& 8		& 10	& yes \\ \hline
		Piccolo~\cite{10.1007/978-3-642-23951-9_23}			& 25	& 8		& 10	& yes \\ \hline
		PRIDE~\cite{10.1007/978-3-662-44371-2_4}			& 20	& 8		& 16	& no  \\ \hline
		PRINCE~\cite{10.1007/978-3-642-34961-4_14}			& 12	& 8		& 16	& yes \\ \hline
		RC5-20~\cite{10.1007/3-540-60590-8_7}				& 20	& 8		& 10	& yes \\ \hline
		RECTANGLE-K80~\cite{Zhang2015}						& 25	& 8		& 16	& no \\ \hline
		RECTANGLE-K128~\cite{Zhang2015}						& 25	& 8		& 16	& no \\ \hline
		RoadRunneR-K80~\cite{10.1007/978-3-319-29078-2_4}	& 10	& 8		& 10	& yes \\ \hline
		RoadRunneR-K128~\cite{10.1007/978-3-319-29078-2_4}	& 12	& 8		& 16	& yes \\ \hline
		Robin~\cite{grosso2014ls}							& 16	& 16	& 16	& yes \\ \hline
		RobinStar~\cite{grosso2014ls}						& 16	& 16	& 16	& yes \\ \hline
		SPARX-B64~\cite{10.1007/978-3-662-53887-6_18}		& 8		& 8		& 16	& yes \\ \hline
		SPARX-B128~\cite{10.1007/978-3-662-53887-6_18}		& 8		& 16	& 16	& yes \\ \hline
		TWINE~\cite{twine}									& 35	& 8		& 10	& yes \\ \hline
		
		
	\end{tabular}
	\caption{List of all investigated functions, where sizes are given in Bytes. Including information whether encrypt decrypt test passed.}
	\label{table:list-of-investigated functions}
\end{table}



\chapter{Results of evaluation of statistical randomness properties}


%%bibliography

\printbibliography[heading=bibintoc] %% Print the bibliography.

\appendix{}

\end{document}
